import { loader } from 'webpack';
import { createInstrumenter } from 'istanbul-lib-instrument';
import { RawSourceMap } from 'source-map';
import { MappingItem, SourceMapConsumer, SourceMapGenerator } from 'source-map';
import { getConfig } from 'intern/lib/node/util';

/**
 * Instrument a source file with istanbul for code coverage.
 *
 * Instrumenter options will be read from the project 'intern.json' file.
 *
 * @param content the source code
 * @param sourceMap an optional source map
 */
export default <loader.Loader>function(
	content: string,
	sourceMap?: string | Buffer
) {
	const callback = this.async()!;
	const options = this.options;

	getConfig(options.config)
		.then(({ config, file }) => {
			// If a config file was successfully loaded, mark it as a dependency
			if (file) {
				this.addDependency(file);
			}
			return config;
		})
		.catch(_error => Object.create(null))
		.then(config => {
			const instrumenterOptions = {
				produceSourceMap: true,
				...config.instrumenterOptions
			};

			if (config.coverageVariable) {
				instrumenterOptions.coverageVariable = config.coverageVariable;
			}

			const instrumenter = createInstrumenter(instrumenterOptions);
			let rawSourceMap: RawSourceMap | undefined;

			// For the code coverage to work we need to modify the sources in the
			// source map to point back to the original file. The files coming in have
			// been generated by webpack and look like,
			// "node_modules/tslint-loader?!path/to/file/css-modules!path/to/file.ts.
			// We need these files to simply be "path/to/file.ts".
			if (isRawSourceMap(sourceMap)) {
				rawSourceMap = sourceMap;
				sourceMap.sources = sourceMap.sources.map(source => {
					const lastBang = source.lastIndexOf('!');
					if (lastBang !== -1) {
						return source.substr(lastBang + 1);
					}
					return source;
				});
			}

			instrumenter.instrument(
				content,
				this.resourcePath,
				(error, instrumentedSource) => {
					if (error) {
						callback(error);
					} else {
						const instrumentedSourceMap = instrumenter.lastSourceMap();
						if (rawSourceMap) {
							rawSourceMap = mergeSourceMaps(
								instrumentedSourceMap,
								rawSourceMap
							);
						} else {
							rawSourceMap = instrumentedSourceMap;
						}

						callback(
							null,
							instrumentedSource,
							JSON.stringify(rawSourceMap)
						);
					}
				},
				rawSourceMap
			);
		});
};

/**
 * Type guard for RawSourceMap objects
 */
function isRawSourceMap(value: any): value is RawSourceMap {
	return value && value.sources != null;
}

/**
 * Merge a list of source maps generated through successive transforms of a
 * single file.
 *
 * Maps should be in reverse order (i.e., the first map should be
 * from the most recent transform).
 *
 * @param maps an array of raw source maps in order from the most recently
 * generated map to the original map
 * @returns a source map that maps locations in the final transformed file to
 * the original file
 */
function mergeSourceMaps(...maps: RawSourceMap[]) {
	const consumers = maps.map(map => new SourceMapConsumer(map));
	const generator = new SourceMapGenerator({ file: maps[0].file });

	// Walk through each mapping of the most recent source map
	consumers[0].eachMapping(mapping => {
		const original = getOriginalPosition(consumers, mapping);
		if (original.line !== null) {
			generator.addMapping({
				generated: {
					line: mapping.generatedLine,
					column: mapping.generatedColumn!
				},
				original: {
					line: original.line,
					column: original.column!
				},
				source: mapping.source!,
				name: mapping.name
			});
		}
	});

	return generator.toJSON();
}

/**
 * Find the original position for a given position.
 *
 * @param consumers a list of source map consumers, from the most recently
 * generated to the original
 * @param mapping a mapping item from the most recent source map
 * @returns a position in the original file
 */
function getOriginalPosition(
	consumers: SourceMapConsumer[],
	mapping: MappingItem
) {
	return consumers.reduce(
		(original, consumer) => {
			// Ignore missing mappings
			if (original.line === null) {
				return original;
			}
			return consumer.originalPositionFor(original);
		},
		{ line: mapping.generatedLine, column: mapping.generatedColumn }
	);
}
